import{expect as e}from"chai";import t from"@bitcoin-computer/bitcore-mnemonic-ltc";t.bitcore;const{CHAIN:n,NETWORK:r,BCN_URL:o,RPC_USER:i,RPC_PASSWORD:f,TEST_MNEMONICS:c}=process.env;const a=n||"LTC";const s=r||"testnet";parseInt(process.env.BC_DUST_LIMIT||"",10),parseInt(process.env.BC_DEFAULT_FEE||"",10),parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10),parseInt(process.env.MWEB_HEIGHT||"",10);const{PublicKey:u,crypto:d}=t.bitcore;const{Point:h}=d;function b(e){return Buffer.from(e).toString("hex")}function l(e){return Buffer.from(e,"hex").toString().replace(/\0/g,"")}function q(e,t){return e.slice(t)+e.slice(0,t)}function p(e,t){return e.slice(-t)+e.slice(0,-t)}function g(e,t,n){if(e.length*Math.log2(t)>53)throw new Error(`Input too large ${e.length} ${Math.log2(t)}`);if(![2,10,16].includes(t)||![2,10,16].includes(n))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===t&&e.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===t&&e.length%2!=0)throw new Error("Hex strings must be of even length.");const r=parseInt(e,t).toString(n);return 2===n?r.padStart(8*Math.ceil(r.length/8),"0"):16===n?r.padStart(2*Math.ceil(r.length/2),"0"):r}function m(e,t){const n=new RegExp(`.{1,${t}}`,"g");return e.match(n)||[]}function w(e){return m(e,2).map((e=>g(e,16,2))).join("")}function E(e){return m(e,8).map((e=>g(e,2,16))).join("")}function T(e){return e.toString(16).padStart(3,"0")}function S(e){return parseInt(e,16)}function x(e){if(62!==e.length)throw new Error("Input to hexToPublicKey must be of length 62");let t=!1;let n=0;let r;for(;!t;){if(n>=256)throw new Error("Something went wrong storing data");const o=n.toString(16).padStart(2,"0")+E(q(w(e).padStart(64,"0"),n));try{r=h.fromX(!1,o),t=!0}catch(e){n+=1}}if(!r)throw new Error("Something went wrong storing data");return new u(r)}function _(e){const t=e.point.getX().toString("hex").padStart(64,"0");const n=g(t.slice(0,2),16,10);const r=parseInt(n,10);return E(p(w(t.slice(2)),r))}function A(e=a,t=s){if("testnet"===t||"regtest"===t)return 1;if("BTC"===e)return 0;if("LTC"===e)return 2;if("DOGE"===e)return 3;if("BCH"===e)return 145;if("BSV"===e)return 236;throw new Error(`Unsupported chain ${e}`)}function I({purpose:e=44,coinType:t=2,account:n=0}={}){return`m/${e.toString()}'/${t.toString()}'/${n.toString()}'`}function y({chain:e=a,network:t=s}={}){return I({coinType:A(e,t)})}function N(){return Math.round(Math.random()*Math.pow(2,31))}function v({chain:e=a,network:t=s,account:n=N()}={}){return I({account:n,coinType:A(e,t)})}describe("utils",(()=>{describe("asciiToHex",(()=>{it("should convert a string to a hex",(()=>{e(b("aaa")).eq("616161"),e(b("111")).eq("313131"),e(b("const s1 = 'Ã©'")).eq("636f6e7374207331203d2027c3a927"),e(b("Ã©")).eq("c3a9"),e(b("ðŸ‘©")).eq("f09f91a9")})),it("should be the inverse of hexToAscii",(()=>{e(l(b("aaa"))).eq("aaa"),e(l(b("111"))).eq("111"),e(l(b("const s1 = 'Ã©'"))).eq("const s1 = 'Ã©'"),e(l(b("Ã©"))).eq("Ã©"),e(l(b("ðŸ‘©"))).eq("ðŸ‘©")}))})),describe("hexToAscii",(()=>{it("should convert a hex to a string",(()=>{e(l("616161")).eq("aaa"),e(l("313131")).eq("111"),e(l("636f6e7374207331203d2027c3a927")).eq("const s1 = 'Ã©'"),e(l("c3a9")).eq("Ã©"),e(l("f09f91a9")).eq("ðŸ‘©")})),it("should be the inverse of asciiToHex",(()=>{e(b(l("616161"))).eq("616161"),e(b(l("313131"))).eq("313131"),e(b(l("636f6e7374207331203d2027c3a927"))).eq("636f6e7374207331203d2027c3a927"),e(b(l("c3a9"))).eq("c3a9")}))})),describe("intToHex",(()=>{it("should convert an integer to a hex",(()=>{e(T(0)).eq("000"),e(T(16)).eq("010"),e(T(2048)).eq("800"),e(T(Number.MAX_SAFE_INTEGER)).eq("1fffffffffffff"),e(T(Number.MAX_SAFE_INTEGER+1)).eq("20000000000000"),e(T(Number.MAX_VALUE)).eq("fffffffffffff800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")})),it("should be the inverse of hexToInt",(()=>{e(S(T(0))).eq(0),e(S(T(16))).eq(16),e(S(T(Number.MAX_SAFE_INTEGER))).eq(Number.MAX_SAFE_INTEGER),e(S(T(Number.MAX_SAFE_INTEGER+1))).eq(Number.MAX_SAFE_INTEGER+1),e(S(T(Number.MAX_VALUE))).eq(Number.MAX_VALUE)}))})),describe("hexToInt",(()=>{it("should convert a hex to an integer",(()=>{e(S("0")).eq(0),e(S("10")).eq(16),e(S("ff")).eq(255),e(S("fff")).eq(4095),e(S("ffff")).eq(65535),e(S("1fffffffffffff")).eq(Number.MAX_SAFE_INTEGER),e(S("20000000000000")).eq(Number.MAX_SAFE_INTEGER+1),e(S("fffffffffffff800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")).eq(Number.MAX_VALUE)})),it("should be the inverse of hexToInt",(()=>{e(T(S("0"))).eq("000"),e(T(S("10"))).eq("010"),e(T(S("1fffffffffffff"))).eq("1fffffffffffff"),e(T(S("20000000000000"))).eq("20000000000000"),e(T(S("fffffffffffff800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"))).eq("fffffffffffff800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")}))})),describe("rotateRight",(()=>{it("should rotate a string",(()=>{e(q("abcde",2)).eq("cdeab"),e(q("abcde",5)).eq("abcde"),e(q("abcde",0)).eq("abcde"),e(q("73b438d64ad669ba462cd097a2e327c23c5716fb03b95272228726b1dd8c9c",2)).eq("b438d64ad669ba462cd097a2e327c23c5716fb03b95272228726b1dd8c9c73")})),it("should be the inverse of rotateLeft",(()=>{const t="abcdefg";e(p(q(t,3),3)).eq(t)}))})),describe("rotateLeft",(()=>{it("should rotate a string",(()=>{e(p("abcde",2)).eq("deabc"),e(p("abcde",5)).eq("abcde"),e(p("abcde",0)).eq("abcde"),e(p("73b438d64ad669ba462cd097a2e327c23c5716fb03b95272228726b1dd8c9c",2)).eq("9c73b438d64ad669ba462cd097a2e327c23c5716fb03b95272228726b1dd8c")})),it("should be the inverse of rotateRight",(()=>{const t="abcdefg";e(q(p(t,3),3)).eq(t)}))})),describe("convertNumber",(()=>{it("should convert a binary string to hex",(()=>{e(g("00000001",2,16)).eq("01"),e(g("00000011",2,16)).eq("03"),e(g("00000111",2,16)).eq("07"),e(g("00001111",2,16)).eq("0f"),e(g("00010000",2,16)).eq("10")})),it("should convert a hex string to binary",(()=>{e(g("01",16,2)).eq("00000001"),e(g("03",16,2)).eq("00000011"),e(g("07",16,2)).eq("00000111"),e(g("0f",16,2)).eq("00001111"),e(g("10",16,2)).eq("00010000")})),it("should be able to compute the inverse",(()=>{const t="10";const n=g(t,16,2);e(n).eq("00010000"),e(g(g(t,16,2),2,16)).eq(t)})),it("should be able to compute the inverse of a large number",(()=>{const t="f".repeat(12);e(g(g(t,16,2),2,16)).eq(t)})),it("should throw an error if the input is too large",(()=>{const t="f".repeat(14);e((()=>g(t,16,2))).throws()}))})),describe("hexToBin",(()=>{it("should convert a hex string to a binary string",(()=>{e(w("01")).eq("00000001"),e(w("03")).eq("00000011"),e(w("07")).eq("00000111"),e(w("0f")).eq("00001111"),e(w("10")).eq("00010000"),e(w("f".repeat(14))).eq("1".repeat(56))}))})),describe("binToHex",(()=>{it("should convert a binary string to a hex string",(()=>{e(E("00000001")).eq("01"),e(E("00000011")).eq("03"),e(E("00000111")).eq("07"),e(E("00001111")).eq("0f"),e((()=>E("1"))).throws("Binary strings must be byte aligned.")}))})),describe("chunkString",(()=>{it("should split up an array",(()=>{e(m("1234567",2)).to.deep.eq(["12","34","56","7"]),e(m("",2)).to.deep.eq([])}))})),describe("chunkArray",(()=>{it("should split up an array",(()=>{e(function(e,t){const n=[];for(let t=0;t<e.length;t+=2)n.push(e.slice(t,t+2));return n}([1,2,3,4,5,6,7])).to.deep.eq([[1,2],[3,4],[5,6],[7]])}))})),describe("hexToPublicKey",(()=>{it("should convert a hex string to a public key without shifting",(()=>{const t=x(b("1").padStart(62,"0"));e(t).to.not.be.undefined})),it("should convert a hex string to a public key with shifting",(()=>{const t=x(b("11").padStart(62,"0"));e(t).to.not.be.undefined})),it("should throw an error if the input is not of length 62",(()=>{e((()=>x("1"))).throws("Input to hexToPublicKey must be of length 62")}))})),describe("publicKeyToHex",(()=>{it("should work with a publicKeyToHex without rotating",(()=>{const t=b("11").padStart(62,"0");const n=_(x(t));e(n).eq(t)})),it("should work with a publicKeyToHex with rotating",(()=>{const t="1".padStart(62,"0");const n=_(x(t));e(n).eq(t)})),it("should work with a random input",(()=>{const t=(e=>{let t="";const n="abcdef0123456789";for(let e=0;e<62;e+=1)t+=n.charAt(Math.floor(Math.random()*n.length));return t})();const n=_(x(t));e(n).eq(t)})),it("should perform round trip between ascii and a public key",(()=>{const t="qwerty";const n=l(_(x(b(t).padStart(62,"0"))));e(n).to.be.deep.eq(t)})),it("should perform round trip between ascii and a public key",(()=>{const t="5b7b2261223a317d5d";const n=l(_(x(b(t).padStart(62,"0"))));e(n).to.be.deep.eq(t)}))})),describe("getCoinType",(()=>{it("should work",(()=>{e(A()).eq(1),e(A("LTC","mainnet")).eq(2)}))})),describe("getPath",(()=>{it("should work",(()=>{e(y()).eq("m/44'/1'/0'"),e(y({chain:"LTC",network:"mainnet"})).eq("m/44'/2'/0'")}))})),describe("getIndexPath",(()=>{it("should work",(()=>{e(v()).to.be.an("string"),e(v({chain:"LTC",network:"mainnet",account:123})).eq("m/44'/2'/123'")}))})),describe("getRandomIntegerInsecure",(()=>{it("should work",(()=>{e(N()).to.be.an("number")}))}))}));
