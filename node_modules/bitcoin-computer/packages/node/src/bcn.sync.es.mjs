import{backOff as t}from"exponential-backoff";import{Computer as e}from"@bitcoin-computer/lib";import s from"dotenv";import n from"is-primitive";import r from"is-plain-object";import o from"fs";import a from"os";import{dirname as i}from"path";import{fileURLToPath as c}from"url";import{createLogger as l,format as d,transports as p}from"winston";import u from"bitcoind-rpc";import y from"util";import f from"pg-promise";import h from"pg-monitor";import g from"@bitcoin-computer/bitcore-lib-ltc";const{deleteProperty:m}=Reflect;const S=n;const b=r;const v=t=>"object"==typeof t&&null!==t||"function"==typeof t;const w=t=>{if(!S(t))throw new TypeError("Object keys must be strings or symbols");if((t=>"__proto__"===t||"constructor"===t||"prototype"===t)(t))throw new Error(`Cannot set unsafe key: "${t}"`)};const $=(t,e)=>e&&"function"==typeof e.split?e.split(t):"symbol"==typeof t?[t]:Array.isArray(t)?t:((t,e,s)=>{const n=(t=>Array.isArray(t)?t.flat().map(String).join(","):t)(e?((t,e)=>{if("string"!=typeof t||!e)return t;let s=t+";";return void 0!==e.arrays&&(s+=`arrays=${e.arrays};`),void 0!==e.separator&&(s+=`separator=${e.separator};`),void 0!==e.split&&(s+=`split=${e.split};`),void 0!==e.merge&&(s+=`merge=${e.merge};`),void 0!==e.preservePaths&&(s+=`preservePaths=${e.preservePaths};`),s})(t,e):t);w(n);const r=T.cache.get(n)||s();return T.cache.set(n,r),r})(t,e,(()=>((t,e={})=>{const s=e.separator||".";const n="/"!==s&&e.preservePaths;if("string"==typeof t&&!1!==n&&/\//.test(t))return[t];const r=[];let o="";const a=t=>{let e;""!==t.trim()&&Number.isInteger(e=Number(t))?r.push(e):r.push(t)};for(let e=0;e<t.length;e++){const n=t[e];"\\"!==n?n!==s?o+=n:(a(o),o=""):o+=t[++e]}return o&&a(o),r})(t,e)));const E=(t,e,s,n)=>{if(w(e),void 0===s)m(t,e);else if(n&&n.merge){const r="function"===n.merge?n.merge:Object.assign;r&&b(t[e])&&b(s)?t[e]=r(t[e],s):t[e]=s}else t[e]=s;return t};const T=(t,e,s,n)=>{if(!e||!v(t))return t;const r=$(e,n);let o=t;for(let t=0;t<r.length;t++){const e=r[t];const a=r[t+1];if(w(e),void 0===a){E(o,e,s,n);break}"number"!=typeof a||Array.isArray(o[e])?(v(o[e])||(o[e]={}),o=o[e]):o=o[e]=[]}return t};T.split=$,T.cache=new Map,T.clear=()=>{T.cache=new Map};var O=T;var R=o;var N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var H="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var _=function(){function t(t,e){for(var s=0;s<e.length;s++){var n=e[s];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,s,n){return s&&t(e.prototype,s),n&&t(e,n),e}}();var I=function t(e,s){var n=s.indexOf(".");if(!~n){if(null==e)return;return e[s]}var r=s.substring(0,n),o=s.substring(n+1);if(null!=e)return e=e[r],o?t(e,o):e},P=O,x=function(t,e){if("function"!=typeof e)return JSON.parse(R.readFileSync(t));R.readFile(t,"utf-8",(function(t,s){try{s=JSON.parse(s)}catch(e){t=t||e}e(t,s)}))},A=o,k=a;var M=function(){function t(e,s){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=s=s||{},s.stringify_width=s.stringify_width||2,s.stringify_fn=s.stringify_fn||null,s.stringify_eol=s.stringify_eol||!1,s.ignore_dots=s.ignore_dots||!1,this.path=e,this.data=this.read()}return _(t,[{key:"set",value:function(t,e,s){var n=this;return"object"===(void 0===t?"undefined":H(t))?function(t,e){var s=0,n=[];if(Array.isArray(t))for(;s<t.length&&!1!==e(t[s],s);++s);else if("object"===(void 0===t?"undefined":N(t))&&null!==t)for(n=Object.keys(t);s<n.length&&!1!==e(t[n[s]],n[s]);++s);}(t,(function(t,e){P(n.data,e,t,s)})):this.options.ignore_dots?this.data[t]=e:P(this.data,t,e,s),this.options.autosave&&this.save(),this}},{key:"get",value:function(t){return t?this.options.ignore_dots?this.data[t]:I(this.data,t):this.toObject()}},{key:"unset",value:function(t){return this.set(t,void 0)}},{key:"append",value:function(t,e){var s=this.get(t);if(s=void 0===s?[]:s,!Array.isArray(s))throw new Error("The data is not an array!");return s.push(e),this.set(t,s),this}},{key:"pop",value:function(t){var e=this.get(t);if(!Array.isArray(e))throw new Error("The data is not an array!");return e.pop(),this.set(t,e),this}},{key:"read",value:function(t){if(!t)try{return x(this.path)}catch(t){return{}}x(this.path,(function(e,s){t(null,s=e?{}:s)}))}},{key:"write",value:function(t,e){return e?A.writeFile(this.path,t,e):A.writeFileSync(this.path,t),this}},{key:"empty",value:function(t){return this.write("{}",t)}},{key:"save",value:function(t){var e=JSON.stringify(this.data,this.options.stringify_fn,this.options.stringify_width,this.options.stringify_eol);return this.write(this.options.stringify_eol?e+k.EOL:e,t),this}},{key:"toObject",value:function(){return this.data}}]),t}();s.config();const F=new M(`${i(c(import.meta.url))}/../../package.json`,{stringify_eol:!0});const{PORT:C,ZMQ_URL:B,CHAIN:L,NETWORK:j,BCN_ENV:D,BCN_URL:G,DEBUG_MODE:K,POSTGRES_USER:U,POSTGRES_PASSWORD:W,POSTGRES_DB:Y,POSTGRES_HOST:V,POSTGRES_PORT:q,RPC_PROTOCOL:z,RPC_USER:J,RPC_PASSWORD:X,RPC_HOST:Z,RPC_PORT:Q,SERVER_VERSION:tt,DEFAULT_WALLET:et,SYNC_HEIGHT:st,SYNC_INTERVAL_CHECK:nt,POSTGRES_MAX_PARAM_NUM:rt,DB_CONNECTION_RETRY_TIME:ot,SIGNATURE_FRESHNESS_MINUTES:at,ALLOWED_RPC_METHODS:it,NODE_MAX_PROGRESS:ct,SYNC_MAX_PROGRESS:lt,MWEB_HEIGHT:dt,BCDB_START_HEIGHT:pt}=process.env;const ut=L||"LTC";const yt=j||"regtest";const ft=D||"dev";const ht=G||"http://127.0.0.1:3000";const gt=parseInt(K,10)||1;const mt=U||"bcn";const St=W||"bcn";const bt=Y||"bcn";const vt=V||"127.0.0.1";const wt=parseInt(q,10)||"5432";const $t=z||"http";const Et=J||"bcn-admin";const Tt=X||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const Ot=Z||"node";const Rt=parseInt(Q,10)||19332;tt||F.get("version");const Nt=parseInt(st,10)||1;const Ht=parseInt(lt,10)||.97;const _t=parseInt(rt,10)||1e4;const It=parseInt(ot,10)||500;!it||it.split(",").map((t=>new RegExp(t)));const Pt=parseInt(pt||"",10)||0;const xt=l({level:["error","warn","info","http","verbose","debug","silly"][gt],format:d.json(),transports:[new p.Console({format:d.combine(d.colorize(),d.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),d.printf((t=>`[2m${t.timestamp}[0m ${t.level} ${t.message}`)))})],exceptionHandlers:[new p.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new p.File({filename:"logs/rejections.log"})]});const At={maxFiles:1,maxSize:1e5};gt>=0&&xt.add(new p.File({filename:"error.log",level:"error"})),gt>=1&&xt.add(new p.File({filename:"logs/warn.log",level:"warn",...At})),gt>=2&&xt.add(new p.File({filename:"logs/info.log",level:"info",...At})),gt>=3&&xt.add(new p.File({filename:"logs/http.log",level:"http",...At})),gt>=4&&xt.add(new p.File({filename:"logs/verbose.log",level:"verbose",...At})),gt>=5&&xt.add(new p.File({filename:"logs/debug.log",level:"debug",...At}));const kt=new u({protocol:$t,user:Et,pass:Tt,host:Ot,port:Rt});const Mt=y.promisify(u.prototype.createwallet.bind(kt));const Ft=y.promisify(u.prototype.generateToAddress.bind(kt));const Ct=y.promisify(u.prototype.getaddressinfo.bind(kt));const Bt=y.promisify(u.prototype.getBlock.bind(kt));const Lt=y.promisify(u.prototype.getBlockchainInfo.bind(kt));const jt=y.promisify(u.prototype.getBlockHash.bind(kt));const Dt=y.promisify(u.prototype.getRawTransaction.bind(kt));const Gt=y.promisify(u.prototype.getTransaction.bind(kt));const Kt=y.promisify(u.prototype.getNewAddress.bind(kt));const Ut={createwallet:Mt,generateToAddress:Ft,getaddressinfo:Ct,getBlock:Bt,getBlockchainInfo:Lt,getBlockHash:jt,getRawTransaction:Dt,getTransaction:Gt,importaddress:y.promisify(u.prototype.importaddress.bind(kt)),listunspent:y.promisify(u.prototype.listunspent.bind(kt)),sendRawTransaction:y.promisify(u.prototype.sendRawTransaction.bind(kt)),getNewAddress:Kt,sendToAddress:y.promisify(u.prototype.sendToAddress.bind(kt))};const Wt=(t,e)=>Object.assign(new Array(e).fill(null),t);const Yt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:r,user:o,password:a}=e.cn;xt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${r}, user:${o}, password: ${a}`)}},noWarnings:!0};"dev"===ft&&gt>0&&(h.isAttached()?h.detach():(h.attach(Yt),h.setTheme("matrix")));const Vt=f(Yt)({host:vt,port:wt,database:bt,user:mt,password:St,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:qt}=f;class zt{static async select(){return Vt.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncStatus"')}static async update({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}){const n=new qt({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,s]});await Vt.any(n)}}class Jt{static async select(){return zt.select()}static async update(t){await zt.update(t)}}class Xt{static updateSync=async t=>Jt.update(t);static selectSync=async()=>Jt.select()}const{PreparedStatement:Zt}=f;class Qt{static async query(t){const{publicKey:e,classHash:s}=t;if(void 0===e&&void 0===s)return[];let n='SELECT "rev"\n      FROM "NonStandard"\n      WHERE true ';const r=[];e&&(r.push(e),n+=' AND $1 = ANY ("publicKeys")'),s&&(r.push(s),n+=` AND "classHash" = $${r.length}`);const o=new Zt({name:`NonStandard.query.${Math.random()}`,text:n,values:r});return(await Vt.any(o)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,classHash:n}){const r=new Zt({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash") VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING',values:[t,e,s,n]});await Vt.none(r)}static async update({id:t,rev:e,publicKeys:s}){const n=new Zt({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return Vt.none(n)}static async getRevsByIds(t){const e=new Zt({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return Vt.any(e)}static async select(t){const e=new Zt({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return Vt.oneOrNone(e)}}class te{static async select(t){return Qt.select(t)}static async query(t){return Qt.query(t)}static async getRevsByIds(t){return Qt.getRevsByIds(t)}static async insert(t){return Qt.insert(t)}static async update(t){return Qt.update(t)}}const{crypto:ee}=g;const{PreparedStatement:se}=f;class ne{static async select(t){const e=new se({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return Vt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,_t);const s=[];for(let e=1;e<=t.length;e+=1)s.push(`($${e})`);const n=s.join(",");const r=new se({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await Vt.none(r)}}static async count(t){const e=t.map((t=>t.rev));const s=new se({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const n=await Vt.oneOrNone(s);return parseInt(n?.count,10)||0}}const{Transaction:re}=g;const{Input:oe}=re;class ae{static getNonCoinbaseRevs=t=>t.map((t=>oe.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull())).map((({prevTxId:t,outputIndex:e})=>({rev:`${t.toString("hex")}/${e}`})));static insert=async t=>class{static async select(t){return ne.select(t)}static async insert(t){return ne.insert(t)}}.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:ie}=f;class ce{static async select(t){const e=new ie({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return Vt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey]));for(;e.length;){const t=e.splice(0,_t);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const n=s.join(",");const r=new ie({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await Vt.none(r)}}}const{Script:le}=g;class de{static insert=async t=>{const e=t.flatMap((t=>t.tx.outputs.map(((e,s)=>{const n=le.fromBuffer(e._scriptBuffer);let r=n.toAddress(yt).toString("legacy");"false"===r&&(r=null);const o=n.toHex();const a=Math.round(e.satoshis);return{address:r,rev:`${t.txId}/${s}`,scriptPubKey:o,satoshis:a}}))));return class{static async select(t){return ce.select(t)}static async insert(t){return ce.insert(t)}}.insert(e)}}const pe=new e({chain:ut,network:yt,url:ht});class ue{static partialSync=async(t,e,s,n)=>{try{let{result:r}=await Ut.getBlockHash(t);for(;t<=e;){const{result:o}=await Ut.getBlock(r,2);const{tx:a,nextblockhash:i}=o;const c=`Backfilling progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*s).toFixed(4)}%)] Backfilling ${a.length} transactions...`;xt.info(c);let l=[];l=t>=n?await Promise.allSettled(a.map((t=>pe.db.fromTxHex(t.hex)))):await Promise.allSettled(a.map((t=>pe.db.getBcTx(t.hex))));const d=l.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const p=l.filter((t=>"rejected"===t.status)).map((t=>t.reason));p.length&&xt.error(`Failed to parse ${p.length} transactions: ${p.map((t=>t)).join(", ")}`),await this.syncTxs(d,t,n),await Xt.updateSync({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}),r=i,t+=1}}catch(t){xt.error(`Sync action failed with error '${t.message}'`)}};static waitForNode=async()=>{const t=await Ut.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:s}=t.result;const n=`Bitcoind Synced Progress { percentage:${e}%, blocks:${s} }`;if(xt.info(n),parseFloat(t.result.verificationprogress)<=1e-6)throw new Error("Node not ready yet");return t};static sync=async()=>{try{let e=await t((()=>this.waitForNode()),{startingDelay:5e3,timeMultiple:1,numOfAttempts:720});let s=await Xt.selectSync();await Xt.updateSync({syncedHeight:s.syncedHeight,bitcoindSyncedHeight:e.result.blocks,bitcoindSyncedProgress:e.result.verificationprogress});let n=Math.max(Nt,s.syncedHeight+1);const r=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const o=e.result.blocks;const{syncedHeight:a}=s;const i=`Starting sync process { bitcoind.progress:${r}%, bitcoindSyncedHeight:${o}, syncedHeight:${a}, currentBlockHeight:${n} }`;for(xt.info(i);parseFloat(e.result.verificationprogress)<Ht||n<=s.bitcoindSyncedHeight;){await this.partialSync(n,s.bitcoindSyncedHeight,e.result.verificationprogress,Pt),e=await Ut.getBlockchainInfo(),s=await Xt.selectSync(),s.bitcoindSyncedHeight=e.result.blocks,await Xt.updateSync({syncedHeight:s.syncedHeight,bitcoindSyncedHeight:s.bitcoindSyncedHeight,bitcoindSyncedProgress:e.result.verificationprogress});const t=(100*parseFloat(e.result.verificationprogress)).toFixed(4);xt.info(`Bitcoind progress: ${t}%`),n=s.syncedHeight+1}}catch(t){xt.error(`Partial sync action failed with error '${t.message}'`)}};static syncTxs=async(t,e,s)=>{try{const n=(await Promise.allSettled([de.insert(t),ae.insert(t.flatMap((t=>t.tx.inputs)))])).filter((t=>"rejected"===t.status)).map((t=>t.reason));n.length&&xt.error(`Failed to insert outputs and/or inputs ${n.length} currentHeight: ${e} errors: ${n.map((t=>t)).join(", ")}`),e>=s&&t.map((async t=>{const{tx:e,inRevs:s=[],outRevs:n=[],outData:r=[]}=t;try{t.isBcdbTx()&&await class{static add=async(t,e,s)=>{const n=Math.max(t.length,e.length);const r=Wt(t,n);const o=Wt(e,n);const a=(i=o,r.map(((t,e)=>[t,i[e]])));var i;await Promise.all(a.map((async([t,e],n)=>{const{__cls:r="",_owners:o=[]}=s[n]||{};if(null===t&&e)return/^[0-9A-Fa-f]{64}\/\d+$/.test(e),void await te.insert({id:e,rev:e,publicKeys:o,classHash:ee.Hash.sha256(Buffer.from(r)).toString("hex")});if(e&&t){const{id:s,classHash:n}=await te.select(t)||{};await te.update({id:s,rev:e,publicKeys:o,classHash:n})}})))};static query=async t=>te.query(t);static getRevsByIds=async t=>(await te.getRevsByIds(t)).map((t=>t.rev))}.add(s,n,r)}catch(t){xt.error(`Failed to add non-standard tx ${e.txid} ${t.message}`)}})),xt.info(`Synced to '${e}'`)}catch(t){xt.error(`Processing block ${e} failed with error '${t.message}'`)}}}!function(){try{const e=`Synchronizing { url: ${ht}, chain:${ut} network:${yt} }`;xt.info(e),"regtest"!==yt&&(async()=>{await(async()=>{await t((()=>Vt.connect()),{startingDelay:It})})(),await ue.sync()})()}catch(t){xt.error(`Synchronizing failed with error '${t.message}'`)}}();
